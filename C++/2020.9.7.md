# 第一讲
## 定义和声明的区别

### 定义-程序执行时分配相应的内存单元
1. 定义变量意味着该变量分配内存单元
2. 函数定义：程序运行时，函数代码存放在内存中（冯诺依曼“储存程序原理”）
### 声明 描述-不涉及内存分配
1. 外部参照类型($\color{#87CEFA}{extern}$)变量声明
2. 引用
3. 函数原型声明
4. 结构体数据组织形式
5. 函数模板，类模板

ps：多用引用而不是指针
## 左值与右值
1. 左值-具有存储单元的量，并且该单元可写
2. 右值-其值可以被读取的量

左值本质是变量，之所以称为"左值"是因为它可以出现在赋值运算的左侧

```C++
int x = 0;
++x;
--x;
//左值
x++;
x--;
/*
不能为左值
可能和编译器有关
*/
```

## 变量储存类型
### 代码区（code area）
存放程序代码
### 数据区
#### 全局数据区、常量池（data area）
存放全局变量、静态全局变量

静态局部变量、常量

#### 栈区（stack area）
存放局部（自动）变量

#### 堆区（heap area）
存放动态变量

## 变量定义格式
### 在所有的函数之外
1. 全局变量 储存类型 缺省 存放在全局数据区
2. 静态全局 储存类型 $\color{#87CEFA}{static}$ 存放在全局数据区

### 在函数之内
1. 静态局部 储存类型 $\color{#87CEFA}{static}$ 存放在全局数据区(常量池)
2. 局部自动变量 储存类型 $\color{#87CEFA}{auto}$ 或者 缺省 存放在栈区
   
ps.static只在定义的作用域存在并可见，在外面存在但不可见

## 全局变量
在所有函数之外定义、缺省存储类型的变量称为全局变量。

优点：
1. 全局变量存在全局数据区
2. 全局变量在主函数执行之前产生、主函数结束后销毁（生命期是全局的）
3. 全局变量定义语句之后的所有函数中均可以直接对其进行读取访问（作用域范围大，可见性强）

缺点：
1. 不利于维护，移植（不建议程序中使用全局变量）

## 局部静态变量
在函数内定义，储存类型为$\color{#87CEFA}{static}$的变量。
1. 静态局部变量存放在全局数据区
2. 静态局部变量可能不被创建
（程序运行时始终不执行定义它的函数）

## 变量地址
### 变量在储存区域中的具体地址由系统安排
1. 从生命开始到生命期结束，地址值不变
2. 自动变量重新创建时，地址值可能改变

## 变量名
### 实际问题与计算机内存之间的桥梁
1. 表达实际事物的数量
2. 代表计算机内存单元
   
变量名是上述两方面的抽象记号，计算机内存单位是实体

### 变量的引用
变量的应用是变量实体（一个已经存在的变量）的一个别名
```C++
数据类型 & 引用名 = 已存在的变量名;
```
1. 变量的引用只是声明，不是定义，不会另外分配内存空间(长称：引用不占空间)
2. 声明引用时，必须用一个变量实体对其初始化
3. 这样的绑定从引用声明开始，一直到引用声明的生命期结束，**不能更改**！
4. 给变量绑定后赋值一个变量，更改的是引用对象的值

### 常量的应用
可以对字面常量，符号常量，甚至变量取别名
```C++
const 数据类型 & 引用名称 = 常量；
const 数据类型 & 引用名 = 已存在的变量名;
//可以将变量视为常量，但不能将常量作为变量
```

### 引用的绑定
```C++
double x = 2.5;
const double PI = 3.1415926;
const double &rPI = 1/PI, &E = 2.71821828;
const double &rx = x;
cout << rx << endl;
x++;//valid
rx++;//invalid
cout << x << endl;
cout << rx << endl;
double &r = PI;//invalid
```

要求：参数都用引用